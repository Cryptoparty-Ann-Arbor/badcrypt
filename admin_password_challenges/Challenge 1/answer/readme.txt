I changed my mind, instead of releasing the answers weekly, they will be released as they
are finished, and if you want to see how it's done before trying yourselfâ€¦well..you can do that.

The two solutions that I came up with are:

Less interesting:
1) Brute Force: using a password list and hashing all of the passwords on the list looking
for a match. This works because Craig chooses a rather weak password. The source is 
brute_force.cpp. I won't explain this more than to say you plug in a password list into 
the program directory titled "hashlist" and the program will check if you find a hit. No password list included.

More interesting:
2) Analysis: By determining how the hashing algorithm works, a password with an
identical hash can be generated. The source is password_builder.cpp.

Here are the core ideas behind the analysis of the hashing code:

The hash we were trying to solve for was Craig's plaintext hash (unsalted!)
hash: 3006394608 found in the source code.

terms:
dng is a deterministic number generator using a seed, min, and max values
pt is the plaintext to be hashed
pt_sum is the sum of all plaintext characters
random_data is a vector of pregenerated random data for use in hashing

key bit of code:

    for (int i=0; i < pt.length(); i++)
    {
        pt_int.push_back(pt[i]); //filling vector
        pt_sum = pt_sum + pt_int[i]; //sum of character values

    }

    //pre-generated random data 10 entries, of 10 length
    std::vector<std::string> random_data = {"3846870223", "3962687902", "7470852223", "7514179786", "2202953802", "7504486334", "1795029264", "7766294303", "6736111978", "9393656247"};
    

    for (int i=0; i < 10; i++) // Craig doesnt see the need for more than 10
    {
        
        delicious.push_back(random_data[index_i][dng(pt[i % pt.length()],0,9)]); 
        index_i = ((index_i + 1) % 10); // to avoid repetition
    }

    return delicious;
}


    int index_i = dng(pt_sum, 0, 9); //determining index 1

1. Here we see that the initial index is determined by a sum of all the characters 
in the password. Also notice that the password is truncated to 10 characters.

2. If the first index was index 0 ("3846870223") then dng(pt[i % pt.length()],0,9)] in an easier
form to read dng(x,0,9)], x would have to be such that it returns a 0 or a 9 when run through
the number generator, this would give us our expected first hash digit of 3.

3. The index then changes by + 1 mod 10 (to keep wrapping around the random_data vector, therefore string 1 of random_data
corresponding to index 1 would have to contain a 0 in order for index 0 to be a possible starting index. This is the second
character in the hash 3,0,0,6,3,9,4,6,0,8. Therefore the starting index can be checked by
following the increasing index and checking if the number exists in that index string. For example
a starting index of 0 is quickly invalidated when we find that index 9's string does not contain the 
expected value of 8. (this is the last digit of the hash).

4. You can check each initial index to find which indices are possible start points. For
the purposes of finding one valid password, I went with the first valid starting index.

5. A valid initial index (and the only one) for 3006394608 is index 4 ("2202953802")

6. An inspection of the indices in order as they increase (4, 5, 6, 7, 8, 9, 0, 1, 2, 3) 
corresponding with (3, 0, 0, 6, 3, 9, 4, 6, 0, 8) reveals that the 2nd index generated by
dng(pt[i % pt.length()],0,9) or dng(x, 0, 9) - where x is the span of ASCII decimal character table 
codes 33 through 136 - must correspond to indices that give the expected values.

(index 4 initial) 2202953802 needs a 6 to return a 3 (keeping in mind 0 is the first value). Thus the first character's decimal representation
must return a 6 when plugged into dng(character_1, 0, 9) 

(index 5, second index) 7504486334 needs a 2 to return a 0.

And so on for indices 6, 7, 8, 9, 0, 1, 2, 3. Each one requring a second index that will return
the expected hashed result. This gives a series of numbers for the hash: 6-2-4-2-2-0-2-2-3-8.

7. You can then generate a list of dng results by way of all character decimal values
this will give you possible characters for each slot of the hash that match the digits 6-2-4-2-2-0-2-2-3-8.

8. You can then generate a list of dng results by way of all possible pt_sums of 10 
character length by running dng through 33 (the lowest decimal representation of a character used
in the password creation) to 136*10 (10 times the largest decimal representation of a character, 10 
because each potential character is considered). By considering only dng results that
return the correct initial index (4), a list of possible pt_sum are found for the password.

9. By adding up the appropriate returned decimal representations of the characters in such
a way that it equals one of the valid pt_sums, a password can be found.

Using this analysis you can find that for hash 3006394608:

0: Index Not Possible
1: Index Not Possible
2: Index Not Possible
3: Index Not Possible
4: Index Possible
5: Index Not Possible
6: Index Not Possible
7: Index Not Possible
8: Index Not Possible
9: Index Not Possible

indices for hash
6 2 4 2 2 0 2 2 3 8 

integer values for possible characters
40 42 57 69 70 73 80 87 95 109 122 126 

62 68 83 90 91 94 115 119 121 123 125 128 

33 43 44 63 64 66 86 96 98 111 112 

62 68 83 90 91 94 115 119 121 123 125 128 

62 68 83 90 91 94 115 119 121 123 125 128 

41 48 50 85 102 105 107 110 117 118 

62 68 83 90 91 94 115 119 121 123 125 128 

62 68 83 90 91 94 115 119 121 123 125 128 

45 58 61 67 81 82 89 92 97 108 114 131 134 

49 72 75 88 100 

integer values for possible plaintext sums
33 43 44 63 64 66 86 96 98 111 112 139 150 155 175 184 199 213 240 246 281 289 296 311 321 328 331 337 340 346 359 378 382 395 405 407 409 411 414 438 439 467 468 479 483 486 506 513 520 522 524 533 565 566 567 600 610 627 638 647 676 687 720 727 730 733 735 742 747 750 755 765 768 771 781 795 798 810 816 841 842 850 851 853 855 884 885 896 903 920 937 945 997 1010 1011 1016 1050 1060 1069 1098 1108 1112 1116 1119 1140 1141 1142 1159 1167 1175 1188 1190 1191 1227 1238 1251 1257 1268 1275 1286 1301 1310 1317 1336 1348 1354 1359 

10. find a combination of integers that add to a listed plaintext sum, convert the decimal representation to characters to find a valid password:

By adding up 40+62+33+62+62+41+62+62+45+49 (the first accepted characters) we find a pt_sum of 518. This is 2 off from 520, which is an acceptable pt_sum result.
By using 42 instead of 40 for the first decimal representation we correct this and pt_sum now equals 520. (Both 40 and 42 were accepted characters for digit 0; along with (57 69 70 73 80 87 95 109 122 126))

Now a suitable password is found by the ASCII table:

sum of pt decimal representation = pt_sum
42+62+33+62+62+41+62+62+45+49 = 520

converting decimal to characters by ASCII table:
*>!>>)>>-1

This just one valid password! And thankfully all we need.

hash of *>!>>)>>-1 is 3006394608 -- Success!

And when punched into Craig's login app:

ACCESS GRANTED; Welcome Back Craig, 
Unhackable King

Double success!

Craig's hashing algorithm was very suspectible to analysis!








